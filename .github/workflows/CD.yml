name: CD Pipeline

# on:
#  workflow_run:
#    workflows: [ "CI Pipeline" ]
#    types:
# #      - completed
on:
  workflow_dispatch:  # <-- manual trigger only

jobs:
  deploy:
    # if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: self-hosted
    permissions:
      contents: write
    env:
      REPO_URL: "https://github.com/karty11/New_project.git"
      AWS_REGION: "us-west-2"
      EKS_CLUSTER_NAME: "project-cluster"
      cluster_name: "project-cluster"
      SECRETS_MANAGER_NAME: "bankapp/mysql"
      IMAGE_TAG: ${{ github.event.workflow_run.head_commit.id || github.sha }}
      TF_DIR: "terraform"

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install AWS CLI v2 (if missing)
        run: |
          if ! command -v aws >/dev/null 2>&1; then
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip -q awscliv2.zip
            sudo ./aws/install
          else
            echo "aws already installed: $(aws --version)"
          fi

      - name: Ensure prerequisites (yq, jq, helm)
        run: |
          set -euo pipefail
          if ! command -v yq >/dev/null 2>&1; then
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi
          if ! command -v helm >/dev/null 2>&1; then
            curl -fsSL https://get.helm.sh/helm-v3.12.0-linux-amd64.tar.gz -o helm.tar.gz
            tar -xzf helm.tar.gz
            sudo mv linux-amd64/helm /usr/local/bin/helm
          fi
      - name: Ensure openssl & jq installed
        run: |
         sudo apt-get update -y
         sudo apt-get install -y openssl jq

      - name: Ensure kubectl (action)
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Prepare kubeconfig path (persist for next steps)
        run: |
          mkdir -p ~/.kube
          chmod 700 ~/.kube
          echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV
          echo "KUBECONFIG set to $HOME/.kube/config (persisted to GITHUB_ENV)"

      - name: Update kubeconfig for EKS (initial check)
        run: |
          set -euo pipefail
          echo "Using KUBECONFIG=$KUBECONFIG"
          if ! aws sts get-caller-identity >/dev/null 2>&1; then
            echo "AWS credentials not working - aborting"
            aws sts get-caller-identity || true
            exit 2
          fi
          aws eks update-kubeconfig --region "${AWS_REGION}" --name "project-cluster" --kubeconfig "$KUBECONFIG"
          echo "Wrote kubeconfig to $KUBECONFIG"
          ls -l "$KUBECONFIG" || true
          sed -n '1,60p' "$KUBECONFIG" || true

      - name: Verify Kubernetes cluster
        run: |
          kubectl version --output=yaml
          kubectl cluster-info || true
          kubectl get nodes --no-headers -o wide || true

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.1

      - name: Install Terragrunt
        run: |
          curl -L https://github.com/gruntwork-io/terragrunt/releases/download/v0.67.4/terragrunt_linux_amd64 -o terragrunt
          chmod +x terragrunt
          sudo mv terragrunt /usr/local/bin/

      - name: Check terraform/terragrunt versions
        run: |
          terraform -version || true
          terragrunt -version || true

      - name: Terraform init & apply (create IRSA IAM role)
        id: tf
        working-directory: ${{ env.TF_DIR }}
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail
          if [ -z "${EKS_CLUSTER_NAME:-}" ] || [ "${EKS_CLUSTER_NAME}" = "null" ]; then
            echo "EKS_CLUSTER_NAME is not set. Provide repo var 'EKS_CLUSTER_NAME'."
            exit 1
          fi
          terraform init -input=false
          terraform apply -auto-approve -input=false -var="cluster_name=project-cluster" -var="aws_region=us-west-2"
          terraform output -json > tfoutputs.json
          IAM_ROLE_ARN=$(jq -r '.iam_role_arn.value' tfoutputs.json)
          if [ -z "$IAM_ROLE_ARN" ] || [ "$IAM_ROLE_ARN" = "null" ]; then
            echo "Failed to obtain iam_role_arn from terraform outputs"
            exit 1
          fi
          echo "iam_role_arn=$IAM_ROLE_ARN" >> $GITHUB_OUTPUT

      - name: Create external-secrets namespace
        run: |
          kubectl create ns external-secrets || echo "namespace external-secrets already exists"

      - name: Pre-clean External Secrets CRDs (if unmanaged)
        run: |
          set -euo pipefail
          echo "Checking for unmanaged External Secrets CRDs..."
          unmanaged_crds=0
          for crd in externalsecrets.external-secrets.io secretstores.external-secrets.io clustersecretstores.external-secrets.io; do
            if kubectl get crd "$crd" >/dev/null 2>&1; then
              echo "Found CRD: $crd"
              owner=$(kubectl get crd "$crd" -o json | jq -r '.metadata.annotations["meta.helm.sh/release-name"] // empty')
              if [ -z "$owner" ]; then
                echo "CRD $crd is unmanaged â€” deleting"
                kubectl delete crd "$crd"
                unmanaged_crds=$((unmanaged_crds+1))
              else
                echo "CRD $crd is already managed by Helm ($owner)"
              fi
            fi
          done
          echo "Unmanaged CRDs cleaned: $unmanaged_crds"

      - name: Install External Secrets Operator via Helm (with CRDs)
        run: |
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update
          helm upgrade --install external-secrets external-secrets/external-secrets \
            --namespace external-secrets \
            --create-namespace \
            --set installCRDs=true    
          
      - name: Install bankapp DB ExternalSecret & ClusterSecretStore
        run: |
          kubectl apply -f helm/bankapp-chart/templates/clustersecretstore.yaml
         

      - name: Create annotated ServiceAccount for External Secrets (IRSA)
        run: |
          set -euo pipefail
          IAM_ROLE_ARN="${{ steps.tf.outputs.iam_role_arn }}"
          if [ -z "${IAM_ROLE_ARN:-}" ] || [ "${IAM_ROLE_ARN}" = "null" ]; then
            echo "IAM_ROLE_ARN is empty. Aborting."
            exit 1
          fi
          kubectl -n external-secrets get sa external-secrets-sa >/dev/null 2>&1 || kubectl -n external-secrets create sa external-secrets-sa
          kubectl -n external-secrets annotate sa external-secrets-sa eks.amazonaws.com/role-arn="${IAM_ROLE_ARN}" --overwrite
          echo "ServiceAccount external-secrets-sa annotated with ${IAM_ROLE_ARN}"

      - name: Create devproject namespace
        run: |
          kubectl create ns devproject || echo "namespace created"
          
      - name: Install bankapp DB ExternalSecret & ClusterSecretStore
        run: |
          kubectl apply -f helm/bankapp-chart/templates/externalsecret-db.yaml 
        

      - name: Install argocd CLI (if missing)
        run: |
          set -euo pipefail
          if ! command -v argocd >/dev/null 2>&1; then
            curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
            chmod +x argocd
            sudo mv argocd /usr/local/bin/argocd
          fi

      - name: Trigger ArgoCD sync - external-secrets-operator
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${ARGOCD_SERVER:-}" ] || [ -z "${ARGOCD_AUTH_TOKEN:-}" ]; then
            echo "ARGOCD_SERVER or ARGOCD_AUTH_TOKEN not provided; skipping external-secrets-operator sync."
          else
            echo "Syncing external-secrets-operator App via ArgoCD"
            argocd app sync external-secrets-operator --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_AUTH_TOKEN" --grpc-web --insecure --timeout 300
            kubectl -n external-secrets rollout status deploy/kubernetes-external-secrets --timeout=180s || true
            kubectl -n external-secrets get pods -o wide || true
          fi

      - name: Trigger ArgoCD sync - bankapp
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${ARGOCD_SERVER:-}" ] || [ -z "${ARGOCD_AUTH_TOKEN:-}" ]; then
            echo "ARGOCD_SERVER or ARGOCD_AUTH_TOKEN not provided; skipping bankapp sync."
          else
            echo "Syncing bankapp App via ArgoCD"
            argocd app sync bankapp --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_AUTH_TOKEN" --grpc-web --insecure --timeout 300
            kubectl create ns devproject || true
            kubectl -n devproject rollout status deploy/bankapp --timeout=180s || true
            kubectl -n devproject rollout status deploy/mysql --timeout=180s || true
          fi
      
      - name: Wait for ExternalSecret to produce k8s Secret
        run: |
         set -euo pipefail
         echo "Waiting up to 3 minutes for ExternalSecret to become Ready in devproject..."

         # Wait until the ExternalSecret reports Ready=True
         if ! kubectl -n devproject wait --for=condition=Ready \
           externalsecret/bankapp-db-externalsecret \
           --timeout=180s; then
         echo "ExternalSecret did not become Ready in time"
         kubectl -n devproject get externalsecret bankapp-db-externalsecret -o yaml || true
         exit 1
         fi

         echo "ExternalSecret is Ready. Checking for synced Secret..."

         # Verify the Secret was created
         if kubectl -n devproject get secret bankapp-db-externalsecret >/dev/null 2>&1; then
         echo "Secret synced successfully"
         kubectl -n devproject get secret bankapp-db-externalsecret -o yaml || true
         else
         echo "Secret not found even though ExternalSecret is Ready"
         exit 1
         fi

      # - name: Wait for ExternalSecret to produce k8s Secret
      #   run: |
      #     set -euo pipefail
      #     echo "Waiting up to 3 minutes for bankapp-db-credentials k8s Secret in devproject..."
      #     n=0
      #     until kubectl -n devproject get secret bankapp-db-credentials >/dev/null 2>&1 || [ $n -ge 18 ]; do
      #       echo "waiting for secret... ($n)"
      #       n=$((n+1))
      #       sleep 10
      #     done
      #     if kubectl -n devproject get secret bankapp-db-credentials >/dev/null 2>&1; then
      #       echo "Secret created"
      #       kubectl -n devproject get secret bankapp-db-credentials -o yaml || true
      #     else
      #       echo "Secret not found after wait period"
      #       kubectl -n devproject get externalsecrets -o wide || true
      #       kubectl -n devproject describe externalsecrets || true
      #       exit 1
      #     fi

      - name: Final check pods & ExternalSecret status
        run: |
          echo "=== pods in devproject ==="
          kubectl -n devproject get pods -o wide || true
          echo "=== ExternalSecrets ==="
          kubectl -n devproject get externalsecrets -o wide || true

      - name: Add Argo Helm repo & update
        run: |
          helm repo add argo https://argoproj.github.io/argo-helm || true
          helm repo update

      - name: Create argocd namespace
        run: |
          kubectl create ns argocd || echo "namespace argocd already exists"

      - name: Install Argo CD via Helm
        run: |
          helm upgrade --install argocd argo/argo-cd \
            --namespace argocd --create-namespace \
            --values helm/bankapp-chart/argocd-values.yaml

      - name: Wait for argocd components ready (server may be ClusterIP or LB)
        run: |
          kubectl -n argocd rollout status deployment/argocd-server --timeout=120s || true
          kubectl -n argocd rollout status deployment/argocd-repo-server --timeout=120s || true
          kubectl -n argocd rollout status deployment/argocd-application-controller --timeout=120s || true

      - name: Trigger Argo CD sync (if not done earlier)
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
        run: |
          if [ -n "${ARGOCD_SERVER:-}" ] && [ -n "${ARGOCD_AUTH_TOKEN:-}" ]; then
            argocd app sync bankapp \
              --server "$ARGOCD_SERVER" \
              --auth-token "$ARGOCD_AUTH_TOKEN" \
              --grpc-web --insecure --wait || true
          else
            echo "Skipping ArgoCD sync (missing secrets)"
          fi

      - name: Compute target branch
        id: branch
        run: |
          BRANCH="${GITHUB_REF_NAME:-$(jq -r '.workflow_run.head_branch' <<<"$GITHUB_EVENT_PAYLOAD")}"
          if [ -z "$BRANCH" ] || [ "$BRANCH" = "null" ]; then
            BRANCH="main"
          fi
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

      - name: Apply Argo CD Application manifest
        run: |
          kubectl apply -f manifest/argocd-app-bankapp.yaml || true

      - name: Update Helm values.yaml with new image tag and push
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          BRANCH: ${{ steps.branch.outputs.branch }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          set -x
          git push origin "HEAD:${BRANCH}" || true
          echo "Pushed updated commit (if any) to ${BRANCH}."

      - name: Print Argo CD initial admin password (for reference)
        run: |
          echo "Argo CD initial admin password (if autogenerated):"
          kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d || echo "secret not found yet"
